// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cms.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const getBranchesByOwner = `-- name: GetBranchesByOwner :many
SELECT b.id, b.name, b.position, b.city_name, b.country, b.address, b.emoji
FROM branchs b
JOIN stores s ON b.store_id = s.id
WHERE s.owner = $1
`

type GetBranchesByOwnerRow struct {
	ID       int64  `json:"id"`
	Name     string `json:"name"`
	Position string `json:"position"`
	CityName string `json:"city_name"`
	Country  string `json:"country"`
	Address  string `json:"address"`
	Emoji    string `json:"emoji"`
}

func (q *Queries) GetBranchesByOwner(ctx context.Context, owner string) ([]GetBranchesByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getBranchesByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBranchesByOwnerRow{}
	for rows.Next() {
		var i GetBranchesByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Position,
			&i.CityName,
			&i.Country,
			&i.Address,
			&i.Emoji,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCmsOverview = `-- name: GetCmsOverview :one
SELECT 
    -- Tổng số cửa hàng của owner
    (SELECT COUNT(*) 
     FROM stores s 
     WHERE s.owner = $1) AS total_store,

    -- Tổng số chi nhánh thuộc các cửa hàng của owner
    (SELECT COUNT(*) 
     FROM branchs b 
     JOIN stores s ON b.store_id = s.id 
     WHERE s.owner = $1) AS total_branch,

    -- Tổng số sự kiện của owner
    (SELECT COUNT(*) 
     FROM events e 
     WHERE e.owner = $1) AS total_event,

    -- Tổng số user chơi game của owner
    (SELECT COUNT(*) 
     FROM voucher_owner vo 
     JOIN vouchers v ON vo.voucher_id = v.id 
     JOIN events e ON v.event_id = e.id 
     WHERE e.owner = $1) AS total_user_play,

    -- Tổng số user chơi game tháng trước của owner
    (SELECT COUNT(*) 
     FROM voucher_owner vo 
     JOIN vouchers v ON vo.voucher_id = v.id 
     JOIN events e ON v.event_id = e.id 
     WHERE e.owner = $1 
       AND e.start_time >= DATE_TRUNC('month', NOW() - INTERVAL '1 MONTH') 
       AND e.start_time < DATE_TRUNC('month', NOW())) AS last_month_total_user_play
`

type GetCmsOverviewRow struct {
	TotalStore             int64 `json:"total_store"`
	TotalBranch            int64 `json:"total_branch"`
	TotalEvent             int64 `json:"total_event"`
	TotalUserPlay          int64 `json:"total_user_play"`
	LastMonthTotalUserPlay int64 `json:"last_month_total_user_play"`
}

func (q *Queries) GetCmsOverview(ctx context.Context, owner string) (GetCmsOverviewRow, error) {
	row := q.db.QueryRow(ctx, getCmsOverview, owner)
	var i GetCmsOverviewRow
	err := row.Scan(
		&i.TotalStore,
		&i.TotalBranch,
		&i.TotalEvent,
		&i.TotalUserPlay,
		&i.LastMonthTotalUserPlay,
	)
	return i, err
}

const getEventsByOwner = `-- name: GetEventsByOwner :many
SELECT e.id, e.name, e.photo, e.voucher_quantity, e.status, e.start_time, e.end_time, g.type AS game_type
FROM events e
JOIN games g ON e.game_id = g.id
WHERE e.owner = $1
`

type GetEventsByOwnerRow struct {
	ID              int64        `json:"id"`
	Name            string       `json:"name"`
	Photo           string       `json:"photo"`
	VoucherQuantity int32        `json:"voucher_quantity"`
	Status          EventsStatus `json:"status"`
	StartTime       time.Time    `json:"start_time"`
	EndTime         time.Time    `json:"end_time"`
	GameType        string       `json:"game_type"`
}

func (q *Queries) GetEventsByOwner(ctx context.Context, owner string) ([]GetEventsByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getEventsByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventsByOwnerRow{}
	for rows.Next() {
		var i GetEventsByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Photo,
			&i.VoucherQuantity,
			&i.Status,
			&i.StartTime,
			&i.EndTime,
			&i.GameType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentVoucherOwners = `-- name: GetRecentVoucherOwners :many
SELECT 
    vo.username,
    u.full_name,
    u.email,
    u.photo,
    COUNT(vo.voucher_id) AS vouchers_received
FROM voucher_owner vo
JOIN vouchers v ON vo.voucher_id = v.id
JOIN events e ON v.event_id = e.id
JOIN stores s ON e.store_id = s.id
JOIN users u ON vo.username = u.username
WHERE s.owner = $1 -- Chỉ lấy các store của owner
  AND vo.created_at >= NOW() - INTERVAL '1 MONTH'
GROUP BY vo.username, u.full_name, u.email, u.photo
ORDER BY MAX(vo.created_at) DESC
LIMIT 5
`

type GetRecentVoucherOwnersRow struct {
	Username         string `json:"username"`
	FullName         string `json:"full_name"`
	Email            string `json:"email"`
	Photo            string `json:"photo"`
	VouchersReceived int64  `json:"vouchers_received"`
}

func (q *Queries) GetRecentVoucherOwners(ctx context.Context, owner string) ([]GetRecentVoucherOwnersRow, error) {
	rows, err := q.db.Query(ctx, getRecentVoucherOwners, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentVoucherOwnersRow{}
	for rows.Next() {
		var i GetRecentVoucherOwnersRow
		if err := rows.Scan(
			&i.Username,
			&i.FullName,
			&i.Email,
			&i.Photo,
			&i.VouchersReceived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoresByOwner = `-- name: GetStoresByOwner :many
SELECT id, name, business_type
FROM stores
WHERE owner = $1
`

type GetStoresByOwnerRow struct {
	ID           int64  `json:"id"`
	Name         string `json:"name"`
	BusinessType string `json:"business_type"`
}

func (q *Queries) GetStoresByOwner(ctx context.Context, owner string) ([]GetStoresByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getStoresByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoresByOwnerRow{}
	for rows.Next() {
		var i GetStoresByOwnerRow
		if err := rows.Scan(&i.ID, &i.Name, &i.BusinessType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPlayByDate = `-- name: GetUserPlayByDate :many
SELECT 
    DATE(vo.created_at) AS play_date,
    g.type AS game_type,
    COUNT(DISTINCT vo.username) AS total_users
FROM voucher_owner vo
JOIN vouchers v ON vo.voucher_id = v.id
JOIN events e ON v.event_id = e.id
JOIN games g ON e.game_id = g.id
WHERE e.owner = $1
  AND vo.created_at >= NOW() - INTERVAL '2 MONTHS'
GROUP BY play_date, game_type
ORDER BY play_date, game_type
`

type GetUserPlayByDateRow struct {
	PlayDate   pgtype.Date `json:"play_date"`
	GameType   string      `json:"game_type"`
	TotalUsers int64       `json:"total_users"`
}

func (q *Queries) GetUserPlayByDate(ctx context.Context, owner string) ([]GetUserPlayByDateRow, error) {
	rows, err := q.db.Query(ctx, getUserPlayByDate, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserPlayByDateRow{}
	for rows.Next() {
		var i GetUserPlayByDateRow
		if err := rows.Scan(&i.PlayDate, &i.GameType, &i.TotalUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStatsByStore = `-- name: GetUserStatsByStore :many
SELECT 
    s.id AS store_id,
    s.name AS store_name,
    COUNT(DISTINCT vo.username) AS total_users
FROM voucher_owner vo
JOIN vouchers v ON vo.voucher_id = v.id
JOIN events e ON v.event_id = e.id
JOIN stores s ON e.store_id = s.id
WHERE e.owner = $1
  AND vo.created_at >= NOW() - INTERVAL '6 MONTHS'
GROUP BY s.id, s.name
ORDER BY total_users DESC
`

type GetUserStatsByStoreRow struct {
	StoreID    int64  `json:"store_id"`
	StoreName  string `json:"store_name"`
	TotalUsers int64  `json:"total_users"`
}

func (q *Queries) GetUserStatsByStore(ctx context.Context, owner string) ([]GetUserStatsByStoreRow, error) {
	rows, err := q.db.Query(ctx, getUserStatsByStore, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserStatsByStoreRow{}
	for rows.Next() {
		var i GetUserStatsByStoreRow
		if err := rows.Scan(&i.StoreID, &i.StoreName, &i.TotalUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoucherOwnersByEvent = `-- name: GetVoucherOwnersByEvent :many
SELECT vo.username, u.full_name, u.email, v.id AS voucher_id, v.type AS voucher_type, v.status AS voucher_status
FROM voucher_owner vo
JOIN vouchers v ON vo.voucher_id = v.id
JOIN users u ON vo.username = u.username
WHERE v.event_id = $1
`

type GetVoucherOwnersByEventRow struct {
	Username      string `json:"username"`
	FullName      string `json:"full_name"`
	Email         string `json:"email"`
	VoucherID     int64  `json:"voucher_id"`
	VoucherType   string `json:"voucher_type"`
	VoucherStatus string `json:"voucher_status"`
}

func (q *Queries) GetVoucherOwnersByEvent(ctx context.Context, eventID int64) ([]GetVoucherOwnersByEventRow, error) {
	rows, err := q.db.Query(ctx, getVoucherOwnersByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVoucherOwnersByEventRow{}
	for rows.Next() {
		var i GetVoucherOwnersByEventRow
		if err := rows.Scan(
			&i.Username,
			&i.FullName,
			&i.Email,
			&i.VoucherID,
			&i.VoucherType,
			&i.VoucherStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoucherStatsByMonth = `-- name: GetVoucherStatsByMonth :many
SELECT 
    TO_CHAR(DATE_TRUNC('month', vo.created_at), 'YYYY-MM') AS month, -- Trả về chuỗi định dạng YYYY-MM
    g.type AS game_type,
    COUNT(*) AS total_vouchers
FROM voucher_owner vo
JOIN vouchers v ON vo.voucher_id = v.id
JOIN events e ON v.event_id = e.id
JOIN games g ON e.game_id = g.id
WHERE e.owner = $1 -- Chỉ lấy các sự kiện của owner
  AND vo.created_at >= NOW() - INTERVAL '6 MONTHS' -- Chỉ lấy dữ liệu trong 6 tháng gần đây
GROUP BY month, game_type
ORDER BY month
`

type GetVoucherStatsByMonthRow struct {
	Month         string `json:"month"`
	GameType      string `json:"game_type"`
	TotalVouchers int64  `json:"total_vouchers"`
}

func (q *Queries) GetVoucherStatsByMonth(ctx context.Context, owner string) ([]GetVoucherStatsByMonthRow, error) {
	rows, err := q.db.Query(ctx, getVoucherStatsByMonth, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVoucherStatsByMonthRow{}
	for rows.Next() {
		var i GetVoucherStatsByMonthRow
		if err := rows.Scan(&i.Month, &i.GameType, &i.TotalVouchers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVouchersByEvent = `-- name: GetVouchersByEvent :many
SELECT v.id, v.qr_code, v.type, v.status, v.expires_at
FROM vouchers v
WHERE v.event_id = $1
`

type GetVouchersByEventRow struct {
	ID        int64       `json:"id"`
	QrCode    pgtype.Text `json:"qr_code"`
	Type      string      `json:"type"`
	Status    string      `json:"status"`
	ExpiresAt time.Time   `json:"expires_at"`
}

func (q *Queries) GetVouchersByEvent(ctx context.Context, eventID int64) ([]GetVouchersByEventRow, error) {
	rows, err := q.db.Query(ctx, getVouchersByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVouchersByEventRow{}
	for rows.Next() {
		var i GetVouchersByEventRow
		if err := rows.Scan(
			&i.ID,
			&i.QrCode,
			&i.Type,
			&i.Status,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
